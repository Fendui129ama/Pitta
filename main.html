<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pitta — Trading Aggregator · FireTrader</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700&family=Geist+Mono:wght@400;500&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --bg: #0f0f12;
      --bg-panel: #18181c;
      --bg-elev: #222228;
      --border: #2e2e36;
      --accent: #f59e0b;
      --accent-soft: rgba(245, 158, 11, 0.18);
      --green: #10b981;
      --green-soft: rgba(16, 185, 129, 0.15);
      --red: #ef4444;
      --red-soft: rgba(239, 68, 68, 0.15);
      --text: #f4f4f5;
      --text-dim: #a1a1aa;
      --radius: 10px;
      --font: 'Outfit', sans-serif;
      --mono: 'Geist Mono', monospace;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--font);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      background-image: radial-gradient(ellipse 90% 50% at 50% -15%, rgba(120, 60, 10, 0.25), transparent);
    }
    .wrap { max-width: 1080px; margin: 0 auto; padding: 1.5rem; }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
      padding-bottom: 1.25rem;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1.25rem;
    }
    .logo { font-weight: 700; font-size: 1.65rem; color: var(--accent); letter-spacing: 0.02em; }
    .tagline { font-size: 0.8rem; color: var(--text-dim); margin-top: 0.2rem; }
    .header-right { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
    input.contract {
      width: 260px;
      padding: 0.5rem 0.75rem;
      font-family: var(--mono);
      font-size: 0.8rem;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: var(--radius);
    }
    input.contract:focus { outline: none; border-color: var(--accent); }
    .addr { font-family: var(--mono); font-size: 0.8rem; color: var(--green); max-width: 140px; overflow: hidden; text-overflow: ellipsis; }
    .btn {
      font-family: var(--font);
      font-weight: 500;
      padding: 0.5rem 1rem;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      color: var(--text);
      cursor: pointer;
      border-radius: var(--radius);
      font-size: 0.9rem;
    }
    .btn:hover { border-color: var(--accent); }
    .btn.primary { background: var(--accent); border-color: var(--accent); color: #0f0f12; }
    .btn.primary:hover { filter: brightness(1.1); }
    .btn.small { padding: 0.35rem 0.7rem; font-size: 0.85rem; }
    .tabs { display: flex; flex-wrap: wrap; gap: 0.3rem; margin-bottom: 1.25rem; }
    .tab {
      padding: 0.55rem 1rem;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      color: var(--text-dim);
      cursor: pointer;
      border-radius: var(--radius);
      font-size: 0.9rem;
    }
    .tab:hover { color: var(--text); }
    .tab.active { border-color: var(--accent); color: var(--accent); background: var(--accent-soft); }
    .panel { display: none; }
    .panel.visible { display: block; }
    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1rem;
      padding: 0.85rem 1rem;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.85rem;
    }
    .stats span { color: var(--text-dim); }
    .stats strong { color: var(--accent); margin-right: 0.25rem; }
    .card {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.15rem;
      margin-bottom: 1rem;
    }
    .card h3 { font-size: 1rem; margin-bottom: 0.75rem; color: var(--accent); }
    .card h4 { font-size: 0.9rem; margin: 0.75rem 0 0.4rem; color: var(--text-dim); }
    label { display: block; font-size: 0.8rem; color: var(--text-dim); margin-bottom: 0.25rem; }
    .input, textarea, select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      font-family: var(--mono);
      font-size: 0.85rem;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: var(--radius);
      margin-bottom: 0.6rem;
    }
    .input:focus, textarea:focus, select:focus { outline: none; border-color: var(--accent); }
    textarea { min-height: 80px; resize: vertical; }
    .row { display: flex; gap: 1rem; flex-wrap: wrap; }
    .row .card { flex: 1; min-width: 260px; }
    .actions { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.75rem; }
    .msg { padding: 0.55rem 0.75rem; border-radius: var(--radius); margin-top: 0.5rem; font-size: 0.85rem; }
    .msg.ok { background: var(--green-soft); border: 1px solid var(--green); color: var(--green); }
    .msg.err { background: var(--red-soft); border: 1px solid var(--red); color: var(--red); }
    .msg.info { background: var(--accent-soft); border: 1px solid var(--accent); color: var(--accent); }
    .list { list-style: none; }
    .list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.6rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.9rem;
    }
    .list li:last-child { border-bottom: none; }
    .list .mono { font-family: var(--mono); font-size: 0.8rem; color: var(--text-dim); }
    .help-box { background: var(--bg-elev); border: 1px solid var(--border); border-radius: var(--radius); padding: 0.85rem; font-size: 0.85rem; color: var(--text-dim); margin-bottom: 1rem; }
    .help-box strong { color: var(--accent); }
    .empty-state { text-align: center; padding: 2rem; color: var(--text-dim); font-size: 0.95rem; }
    pre { font-family: var(--mono); }
    code { font-family: var(--mono); font-size: 0.8em; background: var(--bg-elev); padding: 0.15rem 0.35rem; border-radius: 4px; color: var(--accent); }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    @media (max-width: 768px) { .grid-2 { grid-template-columns: 1fr; } }
    .card-note { border-left: 3px solid var(--accent); }
    .card-warning { border-left: 3px solid var(--red); }
    .btn:focus-visible, .tab:focus-visible, input:focus-visible, textarea:focus-visible, select:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    @media print {
      .stats, .tabs, .btn, .header-right input.contract, .header-right .addr, #wallet-addr, [id^="btn-"] { display: none !important; }
      body { background: #fff; color: #111; }
      .card { border-color: #ccc; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="logo">Pitta</div>
        <p class="tagline">Trading aggregator · FireTrader</p>
      </div>
      <div class="header-right">
        <input type="text" id="contract-address" class="contract" placeholder="FireTrader contract 0x..." />
        <button type="button" class="btn small" id="btn-attach">Attach</button>
        <span class="addr" id="wallet-addr">—</span>
        <button type="button" class="btn primary" id="btn-connect">Connect wallet</button>
      </div>
    </header>

    <div class="stats" id="stats-bar" style="display:none;">
      <span>Venues: <strong id="stat-venues">0</strong></span>
      <span>Fee: <strong id="stat-fee">—</strong> bps</span>
      <span>Paused: <strong id="stat-paused">—</strong></span>
    </div>
    <p class="help-box" id="stats-desc" style="display:none; margin-top:0; margin-bottom:1rem;">Stats bar shows total registered venues, current fee in basis points, and whether the aggregator is paused. Visible after attaching a contract.</p>

    <div class="tabs">
      <button type="button" class="tab active" data-tab="venues">Venues</button>
      <button type="button" class="tab" data-tab="route">Route trade</button>
      <button type="button" class="tab" data-tab="lookup">Lookup route</button>
      <button type="button" class="tab" data-tab="fees">Fees</button>
      <button type="button" class="tab" data-tab="config">Config</button>
    </div>

    <div id="panel-venues" class="panel visible">
      <div class="card" style="margin-bottom:1rem;">
        <p style="font-size:0.9rem; color:var(--text-dim); margin-bottom:0.5rem;">Pitta is the web interface for <strong>FireTrader</strong>, a trading aggregator. Register venues (target contracts), then route trades by sending ETH and calldata. Fees are split between treasury and fee collector.</p>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;"><strong>Venues</strong>: list all venues, register one (owner), toggle active (owner), batch register (owner), load active venue IDs. <strong>Route trade</strong>: choose venue, set min out, paste payload hex, send ETH. <strong>Lookup</strong>: route by ID or venue by ID. <strong>Fees</strong>: view accumulated fees, sweep as treasury or fee collector. <strong>Config</strong>: config, constants, about, glossary, aggregate stats, quick reference, caveats, FAQ.</p>
        <h4>Quick start</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">1. Paste the FireTrader contract address and click Attach. 2. Click Connect wallet and approve the connection. 3. In Venues, check that your target venue exists and is active. 4. In Route trade, enter venue ID, min out (or 0), payload hex, and value in wei. 5. Click Estimate fee then Route trade and confirm in your wallet.</p>
      </div>
      <div class="card">
        <h3>Registered venues</h3>
        <div class="help-box">Venues are target contracts (e.g. DEX or order book). Only owner can register. Route trades send (value − fee) to the venue with your payload. Inactive venues are hidden from routing.</div>
        <div class="actions">
          <button type="button" class="btn small" id="btn-refresh-venues">Refresh</button>
        </div>
        <ul class="list" id="venues-list"></ul>
        <div class="empty-state" id="venues-empty" style="display:none;">No venues or contract not attached.</div>
        <h4 style="margin-top:1rem;">Active venue IDs only</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">List of venue IDs that are currently active (can be used for routing).</p>
        <div class="actions">
          <button type="button" class="btn small" id="btn-active-venues">Load active venue IDs</button>
        </div>
        <pre id="active-venues-out" style="font-size:0.85rem; font-family:var(--mono); color:var(--text-dim); margin-top:0.5rem;"></pre>
      </div>
      <div class="row">
        <div class="card">
          <h4>Register venue (owner only)</h4>
          <label>Target contract address</label>
          <input type="text" id="venue-target" class="input" placeholder="0x..." />
          <label>Label hash (bytes32 hex, or leave empty for 0x0)</label>
          <input type="text" id="venue-label" class="input" placeholder="0x..." />
          <div class="actions">
            <button type="button" class="btn primary" id="btn-register-venue">Register</button>
          </div>
          <div id="register-msg"></div>
        </div>
        <div class="card">
          <h4>Toggle venue active (owner only)</h4>
          <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Disable a venue without removing it. Inactive venues cannot be used for routing.</p>
          <label>Venue ID</label>
          <input type="number" id="toggle-venue-id" class="input" min="1" placeholder="1" />
          <label>Active (checked = active)</label>
          <input type="checkbox" id="toggle-venue-active" checked />
          <div class="actions">
            <button type="button" class="btn small" id="btn-toggle-venue">Set active state</button>
          </div>
          <div id="toggle-msg"></div>
        </div>
      </div>
      <div class="card">
        <h4>Batch register venues (owner only)</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Register multiple venues in one tx. Enter target addresses (one per line or comma-separated). Labels can be one per line or comma-separated; if you provide fewer labels than targets, missing labels are set to 0x0. Max 16 venues per batch. Useful when onboarding several DEX or order-book contracts at once.</p>
        <label>Target addresses (one per line or comma-separated)</label>
        <textarea id="batch-targets" class="input" rows="3" placeholder="0x...&#10;0x..."></textarea>
        <label>Label hashes (one per line or comma; 0x0 or empty for zero)</label>
        <textarea id="batch-labels" class="input" rows="2" placeholder="0x... or empty"></textarea>
        <div class="actions">
          <button type="button" class="btn primary" id="btn-batch-register">Batch register</button>
        </div>
        <div id="batch-register-msg"></div>
      </div>
    </div>

    <div id="panel-route" class="panel">
      <div class="help-box" style="margin-bottom:1rem;">
        <strong>Before you route:</strong> Attach the FireTrader contract and connect your wallet. Confirm the venue is active (Venues tab). Build the payload for the venue (e.g. swap calldata). Enter value in wei; use Estimate fee to see fee and net. Min out is optional; use 0 to skip the check.
      </div>
      <div class="row">
        <div class="card">
          <h3>Route trade</h3>
          <div class="help-box">Send ETH to FireTrader; fee is deducted and the rest is forwarded to the venue with your calldata. Payload is the hex-encoded call to the venue (e.g. swap). Min out is optional (0 = no check).</div>
          <label>Venue ID</label>
          <input type="number" id="route-venue-id" class="input" min="1" placeholder="1" />
          <label>Min amount out (wei; 0 = no check)</label>
          <input type="text" id="route-min-out" class="input" value="0" placeholder="0" />
          <label>Payload (hex calldata for venue)</label>
          <input type="text" id="route-payload" class="input" placeholder="0x..." />
          <label>ETH to send (wei or ETH)</label>
          <input type="text" id="route-value" class="input" placeholder="0.01" />
          <div class="actions">
            <button type="button" class="btn primary" id="btn-route">Route trade</button>
            <button type="button" class="btn small" id="btn-estimate-fee">Estimate fee</button>
          </div>
          <div id="route-msg"></div>
        </div>
        <div class="card">
          <h4>Fee &amp; net</h4>
          <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Fee is (value × feeBps / 10000). Half to treasury, half to fee collector. Net to venue = value − fee.</p>
          <div id="estimate-out" style="font-family:var(--mono); font-size:0.85rem; color:var(--text-dim);"></div>
        </div>
      </div>
      <div class="card">
        <h4>Payload format</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Payload is the hex-encoded calldata sent to the venue contract. For a simple swap you might use the venue's swap function selector (4 bytes) plus ABI-encoded arguments. Example: <code>0x</code> + selector + abi.encode(args). The venue receives (value − fee) as msg.value. If the venue returns a uint256 it is used as amount out and checked against minOutWei when minOutWei &gt; 0.</p>
      </div>
      <div class="card">
        <h4>Route flow</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">1. User sends ETH + payload to FireTrader.routeTrade(venueId, minOut, payload). 2. Contract computes fee = value × feeBps / 10000 and splits it (treasury + fee collector). 3. Contract forwards (value − fee) to the venue via a low-level call with payload. 4. Venue executes (e.g. swap); optional return value is treated as amount out. 5. If minOut &gt; 0 and venue returns a value, contract reverts when return &lt; minOut. 6. Route ID and snapshot are stored and emitted.</p>
      </div>
      <div class="card">
        <h4>Example: building a payload</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Suppose the venue has a function <code>swapExactEthForTokens(uint256 minOut) returns (uint256 amountOut)</code>. The selector is the first 4 bytes of keccak256("swapExactEthForTokens(uint256)"). You would ABI-encode minOut and prepend the selector to get the payload. In JavaScript with ethers: <code>const iface = new ethers.Interface(["function swapExactEthForTokens(uint256) returns (uint256)"]); const payload = iface.encodeFunctionData("swapExactEthForTokens", [minOut]);</code>. Paste the resulting hex (0x...) into the Payload field. The venue will receive (your value − fee) as msg.value.</p>
      </div>
    </div>

    <div id="panel-lookup" class="panel">
      <div class="help-box" style="margin-bottom:1rem;">
        Route IDs are bytes32 values emitted in the TradeRouted event when you call routeTrade. Venue IDs are sequential (1, 2, 3, …) assigned when venues are registered. Use a block explorer to find the routeId from your transaction logs if you did not save it.
      </div>
      <div class="grid-2">
        <div class="card">
          <h3>Lookup route by ID</h3>
          <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Route ID is emitted in TradeRouted. Enter the bytes32 hex (0x + 64 hex chars) to see user, venue, amounts, fee.</p>
          <label>Route ID (bytes32 hex)</label>
          <input type="text" id="lookup-route-id" class="input" placeholder="0x..." />
          <div class="actions">
            <button type="button" class="btn small" id="btn-lookup-route">Lookup</button>
          </div>
          <pre id="lookup-route-out" style="font-size:0.85rem; font-family:var(--mono); color:var(--text-dim); margin-top:0.75rem; white-space:pre-wrap; word-break:break-all;"></pre>
        </div>
        <div class="card">
          <h4>Lookup venue by ID</h4>
          <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Get full venue view: target, label, registered block, active, trade count, volume.</p>
          <label>Venue ID</label>
          <input type="number" id="lookup-venue-id" class="input" min="1" placeholder="1" />
          <div class="actions">
            <button type="button" class="btn small" id="btn-lookup-venue">Lookup venue</button>
          </div>
          <pre id="lookup-venue-out" style="font-size:0.85rem; font-family:var(--mono); color:var(--text-dim); margin-top:0.75rem; white-space:pre-wrap; word-break:break-all;"></pre>
        </div>
      </div>
    </div>

    <div id="panel-fees" class="panel">
      <div class="card" style="margin-bottom:1rem;">
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Every routed trade pays a fee (value × feeBps / 10000). Half is credited to the treasury balance and half to the fee collector. Only those two addresses can sweep their respective accumulated balance. Load fees to see current totals.</p>
        <p style="font-size:0.85rem; color:var(--text-dim);"><strong>Who can sweep:</strong> sweepTreasuryFees() can only be called by the treasury address; sweepCollectorFees() only by the fee collector. If you are not one of these, the buttons will revert on-chain. Connect with the correct wallet to sweep.</p>
      </div>
      <div class="row">
        <div class="card">
          <h3>Accumulated fees</h3>
          <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Treasury and fee collector each accumulate half of the route fee. Sweep to withdraw to your wallet (must be treasury or fee collector).</p>
          <div class="actions">
            <button type="button" class="btn small" id="btn-load-fees">Load fees</button>
          </div>
          <pre id="fees-detail" style="font-size:0.85rem; font-family:var(--mono); color:var(--text-dim); margin-top:0.75rem; white-space:pre-wrap; word-break:break-all;"></pre>
        </div>
        <div class="card">
          <h4>Sweep (treasury / fee collector only)</h4>
          <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Connect as treasury or fee collector address and click the matching button.</p>
          <div class="actions">
            <button type="button" class="btn small" id="btn-sweep-treasury">Sweep treasury</button>
            <button type="button" class="btn small" id="btn-sweep-collector">Sweep fee collector</button>
          </div>
          <div id="sweep-msg"></div>
        </div>
      </div>
    </div>

    <div id="panel-config" class="panel">
      <div class="card">
        <h3>Contract config</h3>
        <p style="margin-bottom:0.5rem; font-size:0.85rem; color:var(--text-dim);">FireTrader immutable addresses and runtime config. Treasury and fee collector are set at deploy and cannot change. Fee bps and paused state can be updated by owner and aggregator keeper respectively.</p>
        <p style="margin-bottom:0.75rem; font-size:0.8rem; color:var(--text-dim);">Load config shows: treasury_, feeCollector_, aggregatorKeeper_, feeBps_, deployedBlock_, aggregatorPaused_.</p>
        <div class="actions">
          <button type="button" class="btn small" id="btn-load-config">Load config</button>
          <button type="button" class="btn small" id="btn-load-constants">Load constants</button>
        </div>
        <pre id="config-detail" style="font-size:0.8rem; font-family:var(--mono); color:var(--text-dim); white-space:pre-wrap; word-break:break-all; margin-top:0.75rem;"></pre>
      </div>
      <div class="card">
        <h4>Contract constants</h4>
        <pre id="constants-out" style="font-size:0.85rem; font-family:var(--mono); color:var(--text-dim); margin-top:0.5rem;"></pre>
      </div>
      <div class="card">
        <h4>About FireTrader</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">FireTrader aggregates trades across venues. Owner registers target contracts (venues). Users route trades by sending ETH and calldata; the contract deducts a fee and forwards the rest to the chosen venue. Fees are split between treasury and fee collector.</p>
        <p style="font-size:0.85rem; color:var(--text-dim);">Payload is the hex-encoded call to the venue contract (e.g. swap selector + encoded args). The venue receives (msg.value − fee) and can return a uint256 (e.g. amount out). Min out is checked only if the venue returns a value.</p>
      </div>
      <div class="card">
        <h4>Glossary</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;"><strong>Venue:</strong> A registered target contract (e.g. DEX, order book). Each venue has an ID, target address, optional label hash, and active flag.</p>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;"><strong>Route:</strong> A single trade execution through one venue. Each route has a unique routeId (bytes32), user, venueId, amount in/out, fee, and block number.</p>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;"><strong>Fee bps:</strong> Fee in basis points; 10000 = 100%. Example: 30 bps = 0.3%. Fee is (value × feeBps) / 10000, split 50/50 between treasury and fee collector.</p>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;"><strong>Treasury:</strong> Immutable address that receives half of routing fees. Only this address can call sweepTreasuryFees().</p>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;"><strong>Fee collector:</strong> Immutable address that receives the other half of fees. Only this address can call sweepCollectorFees().</p>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;"><strong>Payload:</strong> Hex calldata forwarded to the venue. Typically a function selector plus ABI-encoded arguments. The venue receives (value − fee) as msg.value.</p>
        <p style="font-size:0.85rem; color:var(--text-dim);"><strong>Min out:</strong> Optional minimum amount (wei) the venue must return. Enforced only when minOutWei &gt; 0 and the venue returns a uint256.</p>
      </div>
      <div class="card">
        <h4>Aggregate stats</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Total volume and total trades across all venues (read from contract).</p>
        <div class="actions">
          <button type="button" class="btn small" id="btn-aggregate-stats">Load aggregate stats</button>
        </div>
        <pre id="aggregate-stats-out" style="font-size:0.85rem; font-family:var(--mono); color:var(--text-dim); margin-top:0.5rem;"></pre>
      </div>
      <div class="card">
        <h4>Quick reference</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Fee = value × feeBps / 10000. Net to venue = value − fee. Max fee bps is 300. Max venues 64. Payload must be valid calldata for the venue (e.g. swap function selector + ABI-encoded args). Min out is only enforced if the venue returns a uint256.</p>
      </div>
      <div class="card">
        <h4>Caveats</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">Routing sends ETH and arbitrary calldata to the venue. Only register trusted venue contracts. The venue can revert (e.g. slippage); then the whole routeTrade tx reverts. Owner can pause the aggregator. Treasury and fee collector addresses are immutable at deploy.</p>
      </div>
      <div class="card">
        <h4>Constants reference</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;"><strong>BPS base</strong> (10000): basis points denominator. Fee bps is in percent × 100 (e.g. 10 = 0.1%). <strong>Max fee bps</strong> (300): owner cannot set fee above 3%. <strong>Max venues</strong> (64): maximum number of registered venues. <strong>Max batch quote</strong> (16): maximum venues per batch register.</p>
      </div>
      <div class="card">
        <h4>FAQ</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;"><strong>Who can register venues?</strong> Only the contract owner. <strong>Who can sweep fees?</strong> Only the treasury address (sweep treasury) or the fee collector address (sweep fee collector). <strong>What if the venue reverts?</strong> The entire routeTrade transaction reverts and no fee is taken. <strong>Can I route to an inactive venue?</strong> No; the contract reverts with FTR_VenueInactive. <strong>Is there a minimum or maximum trade size?</strong> The contract does not enforce min/max; the venue may.</p>
      </div>
      <div class="card">
        <h4>Contract events</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">FireTrader emits <strong>VenueRegistered</strong> (venueId, target, labelHash), <strong>VenueToggled</strong> (venueId, active), <strong>TradeRouted</strong> (routeId, user, venueId, amountIn, amountOut, feeWei), <strong>FeeSwept</strong> (to, amount, kind), <strong>AggregatorPauseToggled</strong>, <strong>FeeBpsUpdated</strong>, <strong>RouteIdRecorded</strong>. Use these in indexers or to look up route IDs from tx logs.</p>
      </div>
      <div class="card">
        <h4>Testing a route</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">1. Attach the FireTrader contract and connect your wallet. 2. In Venues, confirm the venue you want is listed and active. 3. In Route trade, enter the venue ID. 4. Set min amount out (0 to skip check). 5. Build the payload for your venue (e.g. swap calldata). 6. Enter the ETH amount to send. 7. Click Estimate fee to see fee and net. 8. Click Route trade and confirm the transaction. 9. Use the tx receipt or event logs to get the route ID for lookup.</p>
      </div>
      <div class="card">
        <h4>Security and mainnet</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">FireTrader is designed for mainnet: treasury and fee collector are immutable; only they can sweep their respective fees. The aggregator keeper can pause; the owner can set fee bps (capped) and register or toggle venues. Always verify the contract address on-chain and that you are interacting with the correct chain. Pitta does not hold keys; signing happens in your wallet. Double-check payload and value before routing; a wrong venue or payload can send funds to an unintended contract.</p>
      </div>
      <div class="card">
        <h4>Error codes (reverts)</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">FTR_ZeroTarget, FTR_VenueIdInvalid, FTR_VenueInactive, FTR_AggregatorPaused, FTR_ZeroValue, FTR_MaxVenuesReached, FTR_BatchLengthMismatch, FTR_BatchTooLarge, FTR_FeeBpsTooHigh, FTR_MinOutNotMet, FTR_NotTreasury, FTR_NotFeeCollector. These help you debug failed transactions when the UI shows the revert reason.</p>
      </div>
      <div class="card">
        <h4>Term reference</h4>
        <p style="font-size:0.8rem; color:var(--text-dim); margin-bottom:0.25rem;">venueId: uint256 index of a registered venue. routeId: bytes32 unique id for a route (from event or getRouteSnapshot). target: the contract address that receives the routed value and payload. labelHash: optional bytes32 label for a venue. feeBps: basis points for fee (owner-set, max 300). aggregatorPaused: if true, routeTrade reverts. deployedBlock: block number at deploy. aggregatorKeeper: address that can pause. treasury / feeCollector: immutable fee recipients. getVenueView: returns full venue struct (id, target, labelHash, block, active, tradeCount, volumeWei). getRouteSnapshot: returns route details by routeId. totalVolumeAcrossVenues / totalTradesAcrossVenues: contract-wide stats.</p>
      </div>
      <div class="card card-note">
        <h4>Chain and network</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.5rem;">Pitta works on any EVM chain where FireTrader is deployed. Ensure your wallet is connected to the correct network (e.g. Ethereum mainnet, or the same chain as the contract). The contract address is the same across chains only if the contract was deployed to each chain; verify the address on a block explorer for your chain. All amounts in the UI are in wei (or native token units) unless stated otherwise.</p>
      </div>
      <div class="card">
        <h4>Payload examples (conceptual)</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">Swap exact ETH for tokens: selector for swapExactEthForTokens(minOut) + ABI-encoded minOut. Swap for exact tokens: selector for swapEthForExactTokens(amountOut, path) + encoded args. Generic call: any public/external function selector + encoded parameters. The venue receives msg.value = (your value − fee). Payload must be valid for the venue contract; wrong payload can revert or send funds incorrectly.</p>
      </div>
      <div class="card">
        <h4>Keyboard and accessibility</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">Use Tab to move between inputs and buttons. Enter submits forms where applicable. Focused elements show an accent outline. For route ID lookup, paste the full bytes32 hex (0x + 64 hex chars). Venue IDs are numbers; min out and value are wei (integers).</p>
      </div>
      <div class="card card-warning">
        <h4>Troubleshooting</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">Transaction reverted with FTR_VenueInactive: the venue is toggled off; use an active venue or ask the owner to set it active. FTR_MinOutNotMet: the venue returned less than your min out; increase slippage (lower min out) or try again. FTR_AggregatorPaused: the aggregator is paused; wait until the keeper unpauses. FTR_ZeroValue: you sent 0 wei; add value. Invalid contract address: ensure the FireTrader address is correct and includes 0x. No Ethereum provider: install MetaMask or another Web3 wallet and refresh.</p>
      </div>
      <div class="card">
        <h4>Links and resources</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">Verify the FireTrader contract on your chain’s block explorer (Etherscan, etc.) before attaching. Use the explorer to read contract state (venues, config) and to inspect events (TradeRouted, VenueRegistered). For payload construction, use ethers.Interface or your DEX SDK to encode the venue’s function call. Keep a copy of the contract ABI if you integrate programmatically.</p>
      </div>
      <div class="card">
        <h4>Data formats</h4>
        <p style="font-size:0.8rem; color:var(--text-dim); margin-bottom:0.3rem;">Address: 0x followed by 40 hex chars (20 bytes). Bytes32: 0x + 64 hex chars. Venue ID: integer (1 to max venues). Route ID: bytes32 hex from event. Value / min out / wei: integer string, no decimals. Payload: 0x + hex-encoded calldata (selector + ABI-encoded args). Label hash for register: bytes32; use 0x0 or keccak256 of label string.</p>
      </div>
      <div class="card">
        <h4>Integrating with Pitta</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">Pitta is a single HTML file; you can host it anywhere or run locally. To integrate your app with FireTrader, use the same ABI (see script section) and call the contract with ethers.js or web3.js. For routeTrade, encode the payload with your venue’s interface, pass venueId and minOutWei, and send the transaction with value. Listen for TradeRouted events to get routeId and amountOutWei. For read-only data (venues, config, fees), use the view functions without a signer.</p>
        <p style="font-size:0.85rem; color:var(--text-dim);">Ensure your provider (or wallet) is on the same chain as the deployed FireTrader contract. Chain ID can be read via provider.getNetwork().</p>
      </div>
      <div class="card">
        <h4>Browser support</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">Pitta requires a modern browser with JavaScript enabled and an injected Ethereum provider (e.g. MetaMask). The UI uses standard DOM, CSS, and ethers v6. No build step; open the HTML file or serve it over HTTP/HTTPS. For production, serve over HTTPS and ensure users connect to the correct network.</p>
      </div>
      <div class="card card-warning">
        <h4>Disclaimer</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">Pitta is a front-end interface only; it does not hold funds or private keys. All transactions are signed in your wallet. FireTrader contract behaviour (fees, venues, routing) is determined by the on-chain contract. Always verify the contract address and source code on a block explorer. Use at your own risk; the authors are not liable for loss of funds due to misuse, wrong payload, or contract bugs.</p>
      </div>
      <div class="card">
        <h4>Venue lifecycle</h4>
        <p style="font-size:0.85rem; color:var(--text-dim);">Owner registers a venue with registerVenue(target, labelHash); it receives the next venue ID and is active by default. Owner can setVenueActive(venueId, false) to disable routing to that venue, or true to re-enable. Volume and trade count for the venue accumulate with each routeTrade. Venues cannot be unregistered; deactivate instead if a target is deprecated.</p>
      </div>
      <div class="card">
        <h4>Fee flow</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">On each routeTrade, the contract computes fee = (msg.value × feeBps) / 10000. Half is added to the treasury accumulator and half to the fee collector accumulator. The contract forwards (msg.value − fee) to the venue. Treasury and fee collector do not receive ETH automatically; they must call sweepTreasuryFees() and sweepCollectorFees() to transfer their accumulated balance to themselves.</p>
      </div>
      <div class="card">
        <h4>Pitta and FireTrader</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">Pitta is the companion UI for the FireTrader on-chain trading aggregator. FireTrader is a single contract that holds no custody of user funds beyond the fee split on each trade. Pitta provides forms and read-only views for all main operations; for automation or integration, use the same contract ABI and your own front-end or scripts.</p>
        <p style="font-size:0.85rem; color:var(--text-dim);">Contract addresses and hex values in FireTrader (treasury, fee collector, keeper, domain salt) are set at deployment and are immutable. Do not reuse the same addresses for other deployments.</p>
      </div>
      <div class="card card-note">
        <h4>Summary</h4>
        <p style="font-size:0.85rem; color:var(--text-dim); margin-bottom:0.4rem;">Attach contract → Connect wallet → Venues: list/register/toggle → Route trade: venue ID + payload + value → Lookup: route or venue by ID → Fees: load and sweep (as treasury or collector) → Config: load config and constants, read docs.</p>
        <p style="font-size:0.8rem; color:var(--text-dim);">All actions that change state (register, toggle, route, sweep) require a connected wallet and sufficient gas. Read-only actions work with contract attached and provider (no signer needed for view calls).</p>
      </div>
    </div>
  </div>
  <footer style="margin-top:2rem; padding-top:1rem; border-top:1px solid var(--border); font-size:0.8rem; color:var(--text-dim); text-align:center; max-width:60em; margin-left:auto; margin-right:auto;">
    <p>Pitta — Trading aggregator UI for FireTrader. Connect wallet, attach FireTrader contract. Venues: list venues, register (owner), toggle active (owner), batch register (owner). Route trade: send ETH + payload to a venue; estimate fee before sending. Lookup: route by ID or venue by ID. Fees: load accumulated fees, sweep as treasury or fee collector. Config: view config, load constants (BPS base, max fee bps, max venues, max batch), glossary, aggregate stats, quick reference. All amounts in native ETH (or chain equivalent).</p>
    <p style="margin-top:0.5rem;">UI version: single-file Pitta for FireTrader. Use on EVM mainnets only with verified contract addresses.</p>
  </footer>

  <script>
    /**
     * Pitta — FireTrader web UI
     * Uses ethers v6 to connect wallet and call FireTrader contract.
     * Contract must be attached (address) before most actions.
     * Venues tab: getVenueIds, getVenue, getVenueTradeCount, getVenueVolumeWei; registerVenue, setVenueActive, registerVenuesBatch (owner); getActiveVenueIds.
     * Route trade: routeTrade(venueId, minOutWei, payload) with value; computeFeeForAmount for estimate.
     * Lookup: getRouteSnapshot(routeId), getVenueView(venueId).
     * Fees: getFeeTreasuryAccum, getFeeCollectorAccum; sweepTreasuryFees, sweepCollectorFees (callable only by treasury / fee collector).
     * Config: getConfig, getConstants; aggregate: totalVolumeAcrossVenues, totalTradesAcrossVenues.
     * All numeric inputs (venue ID, min out, value) are in wei or integer; payload is 0x-prefixed hex.
     */
    (function() {
      // DOM refs
      const contractInput = document.getElementById('contract-address');
      const walletAddrEl = document.getElementById('wallet-addr');
      const btnConnect = document.getElementById('btn-connect');
      const btnAttach = document.getElementById('btn-attach');
      const statsBar = document.getElementById('stats-bar');

      // Provider, signer, contract ref; contractAddress persisted for re-attach after connect
      let provider = null;
      let signer = null;
      let contract = null;
      let contractAddress = '';

      const ABI = [
        'function getVenueIds() view returns (uint256[])',
        'function getVenue(uint256 venueId) view returns (address target, bytes32 labelHash, uint256 registeredAtBlock, bool active)',
        'function getVenueTradeCount(uint256 venueId) view returns (uint256)',
        'function getVenueVolumeWei(uint256 venueId) view returns (uint256)',
        'function routeTrade(uint256 venueId, uint256 minOutWei, bytes payload) payable returns (bytes32 routeId, uint256 amountOutWei)',
        'function registerVenue(address target, bytes32 labelHash) returns (uint256)',
        'function setVenueActive(uint256 venueId, bool active)',
        'function getConfig() view returns (address treasury_, address feeCollector_, address aggregatorKeeper_, uint256 feeBps_, uint256 deployedBlock_, bool aggregatorPaused_)',
        'function getFeeTreasuryAccum() view returns (uint256)',
        'function getFeeCollectorAccum() view returns (uint256)',
        'function sweepTreasuryFees()',
        'function sweepCollectorFees()',
        'function computeFeeForAmount(uint256 amountWei) view returns (uint256)',
        'function getActiveVenueIds() view returns (uint256[])',
        'function getRouteSnapshot(bytes32 routeId) view returns (address user, uint256 venueId, uint256 amountInWei, uint256 amountOutWei, uint256 feeWei, uint256 atBlock)',
        'function totalVolumeAcrossVenues() view returns (uint256)',
        'function totalTradesAcrossVenues() view returns (uint256)',
        'function getVenueView(uint256 venueId) view returns (tuple(uint256 venueId, address target, bytes32 labelHash, uint256 registeredAtBlock, bool active, uint256 tradeCount, uint256 volumeWei))',
        'function registerVenuesBatch(address[] targets, bytes32[] labelHashes) returns (uint256[] venueIds)',
        'function getConstants() view returns (uint256 bpsBase, uint256 maxFeeBps, uint256 maxVenues, uint256 maxBatchQuote)'
      ];
      // ABI usage: getVenueIds lists all venue IDs. getVenue(venueId) returns target, labelHash, registeredAtBlock, active. getVenueView(venueId) returns full struct.
      // getVenueTradeCount(venueId) / getVenueVolumeWei(venueId) for per-venue stats. routeTrade(venueId, minOutWei, payload) payable.
      // registerVenue(target, labelHash) and setVenueActive(venueId, active) are owner-only. getConfig returns treasury, feeCollector, keeper, feeBps, deployedBlock, paused.
      // getFeeTreasuryAccum / getFeeCollectorAccum are the accumulated fees. sweepTreasuryFees / sweepCollectorFees transfer to treasury / collector.
      // computeFeeForAmount(amountWei) returns fee for a given value. getActiveVenueIds returns IDs of active venues only.
      // getRouteSnapshot(routeId) returns user, venueId, amountIn, amountOut, fee, atBlock. totalVolumeAcrossVenues / totalTradesAcrossVenues for global stats.
      // getVenueView(venueId) returns full struct. registerVenuesBatch(targets, labelHashes) for batch register. getConstants returns bpsBase, maxFeeBps, maxVenues, maxBatchQuote.

      function showMsg(containerId, text, type) {
        // Display message in given container; type: 'ok' | 'err' | 'info'
        const el = document.getElementById(containerId);
        if (!el) return;
        el.textContent = text;
        el.className = 'msg ' + (type || 'info');
        el.style.display = 'block';
      }

      function hideMsg(containerId) {
        const el = document.getElementById(containerId);
        if (el) { el.style.display = 'none'; el.textContent = ''; }
      }

      async function connectWallet() {
        try {
          if (!window.ethereum) { showMsg('route-msg', 'No Ethereum provider.', 'err'); return; }
          provider = new ethers.BrowserProvider(window.ethereum);
          const accounts = await provider.send('eth_requestAccounts', []);
          if (accounts.length === 0) { showMsg('route-msg', 'No account selected.', 'err'); return; }
          signer = await provider.getSigner();
          const addr = await signer.getAddress();
          walletAddrEl.textContent = addr.slice(0, 6) + '…' + addr.slice(-4);
          walletAddrEl.title = addr;
          if (contractAddress) attachContract(contractAddress);
          loadVenues();
        } catch (e) {
          showMsg('route-msg', e.message || 'Connect failed.', 'err');
        }
      }

      function attachContract(addr) {
        const a = (addr || contractInput.value || '').trim();
        if (!ethers.isAddress(a)) { showMsg('route-msg', 'Invalid contract address.', 'err'); return; }
        contractAddress = a;
        contractInput.value = a;
        try {
          contract = new ethers.Contract(a, ABI, signer || provider);
          statsBar.style.display = 'flex';
          const statsDesc = document.getElementById('stats-desc');
          if (statsDesc) statsDesc.style.display = 'block';
          loadStats();
          loadVenues();
        } catch (e) {
          showMsg('route-msg', e.message || 'Attach failed.', 'err');
        }
      }

      async function loadStats() {
        if (!contract) return;
        try {
          const cfg = await contract.getConfig();
          const ids = await contract.getVenueIds();
          const len = Array.isArray(ids) ? ids.length : (ids && ids.length !== undefined ? Number(ids.length) : 0);
          document.getElementById('stat-venues').textContent = len;
          document.getElementById('stat-fee').textContent = cfg[3].toString();
          document.getElementById('stat-paused').textContent = cfg[5] ? 'Yes' : 'No';
          document.getElementById('stat-paused').style.color = cfg[5] ? 'var(--red)' : 'var(--green)';
        } catch (_) {}
      }

      async function loadVenues() {
        const list = document.getElementById('venues-list');
        const empty = document.getElementById('venues-empty');
        list.innerHTML = '';
        empty.style.display = 'none';
        if (!contract) { empty.style.display = 'block'; return; }
        try {
          const ids = await contract.getVenueIds();
          const len = Array.isArray(ids) ? ids.length : (ids && ids.length !== undefined ? Number(ids.length) : 0);
          if (len === 0) { empty.style.display = 'block'; return; }
          for (let i = 0; i < len; i++) {
            const vid = ids[i];
            try {
              const v = await contract.getVenue(vid);
              const count = await contract.getVenueTradeCount(vid);
              const vol = await contract.getVenueVolumeWei(vid);
              const li = document.createElement('li');
              li.innerHTML = '<span>Venue #' + vid + ' · ' + (v[0] ? v[0].slice(0, 10) + '…' : '—') + '</span>' +
                '<span class="mono">' + (v[3] ? 'active' : 'inactive') + ' · trades ' + count + ' · vol ' + ethers.formatEther(vol || 0) + ' ETH</span>';
              list.appendChild(li);
            } catch (_) {}
          }
        } catch (e) {
          empty.style.display = 'block';
        }
      }

      document.getElementById('btn-refresh-venues').addEventListener('click', loadVenues);

      document.getElementById('btn-active-venues').addEventListener('click', async function() {
        const out = document.getElementById('active-venues-out');
        out.textContent = '';
        if (!contract) { out.textContent = 'Attach contract first.'; return; }
        try {
          const ids = await contract.getActiveVenueIds();
          const len = Array.isArray(ids) ? ids.length : (ids && ids.length !== undefined ? Number(ids.length) : 0);
          out.textContent = len === 0 ? 'No active venues.' : ids.join(', ');
        } catch (e) {
          out.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-toggle-venue').addEventListener('click', async function() {
        const venueId = document.getElementById('toggle-venue-id').value.trim();
        const active = document.getElementById('toggle-venue-active').checked;
        if (!contract || !signer) { showMsg('toggle-msg', 'Connect wallet and attach contract.', 'err'); return; }
        if (!venueId) { showMsg('toggle-msg', 'Enter venue ID.', 'err'); return; }
        try {
          const tx = await contract.setVenueActive(venueId, active);
          showMsg('toggle-msg', 'Tx: ' + tx.hash, 'info');
          await tx.wait();
          showMsg('toggle-msg', 'Venue active state updated.', 'ok');
          loadVenues();
          loadStats();
        } catch (e) {
          showMsg('toggle-msg', e.message || 'Toggle failed.', 'err');
        }
      });

      document.getElementById('btn-lookup-venue').addEventListener('click', async function() {
        const venueId = document.getElementById('lookup-venue-id').value.trim();
        const out = document.getElementById('lookup-venue-out');
        out.textContent = '';
        if (!contract) { out.textContent = 'Attach contract first.'; return; }
        if (!venueId) { out.textContent = 'Enter venue ID.'; return; }
        try {
          const v = await contract.getVenueView(venueId);
          out.textContent = 'Venue ID: ' + v[0] + '\nTarget: ' + v[1] + '\nLabel hash: ' + v[2] + '\nRegistered block: ' + v[3] + '\nActive: ' + v[4] + '\nTrade count: ' + v[5] + '\nVolume wei: ' + v[6];
        } catch (e) {
          out.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-lookup-route').addEventListener('click', async function() {
        const routeId = document.getElementById('lookup-route-id').value.trim();
        const out = document.getElementById('lookup-route-out');
        out.textContent = '';
        if (!contract) { out.textContent = 'Attach contract first.'; return; }
        if (!routeId || !routeId.startsWith('0x') || routeId.length < 66) { out.textContent = 'Enter valid route ID (0x... 66 chars).'; return; }
        try {
          const r = await contract.getRouteSnapshot(routeId);
          out.textContent = 'User: ' + r[0] + '\nVenue ID: ' + r[1] + '\nAmount in: ' + r[2] + ' wei\nAmount out: ' + r[3] + ' wei\nFee: ' + r[4] + ' wei\nBlock: ' + r[5];
        } catch (e) {
          out.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-register-venue').addEventListener('click', async function() {
        const target = document.getElementById('venue-target').value.trim();
        const labelInput = document.getElementById('venue-label').value.trim();
        if (!contract || !signer) { showMsg('register-msg', 'Connect wallet and attach contract.', 'err'); return; }
        if (!target || !ethers.isAddress(target)) { showMsg('register-msg', 'Invalid target address.', 'err'); return; }
        const labelHash = labelInput && labelInput.startsWith('0x') && labelInput.length === 66 ? labelInput : '0x' + '0'.repeat(64);
        try {
          const tx = await contract.registerVenue(target, labelHash);
          showMsg('register-msg', 'Tx: ' + tx.hash, 'info');
          await tx.wait();
          showMsg('register-msg', 'Venue registered.', 'ok');
          loadStats();
          loadVenues();
        } catch (e) {
          showMsg('register-msg', e.message || 'Register failed.', 'err');
        }
      });

      document.getElementById('btn-route').addEventListener('click', async function() {
        hideMsg('route-msg');
        const venueId = document.getElementById('route-venue-id').value.trim();
        const minOut = document.getElementById('route-min-out').value.trim() || '0';
        const payloadRaw = document.getElementById('route-payload').value.trim();
        const valueInput = document.getElementById('route-value').value.trim();
        if (!contract || !signer) { showMsg('route-msg', 'Connect wallet and attach contract.', 'err'); return; }
        if (!venueId || !valueInput) { showMsg('route-msg', 'Fill venue ID and ETH value.', 'err'); return; }
        let valueWei;
        try {
          valueWei = valueInput.includes('.') || /^\d+$/.test(valueInput) ? ethers.parseEther(valueInput) : BigInt(valueInput);
        } catch (_) {
          showMsg('route-msg', 'Invalid value.', 'err');
          return;
        }
        const payload = payloadRaw.startsWith('0x') ? payloadRaw : '0x' + payloadRaw;
        try {
          const tx = await contract.routeTrade(venueId, minOut, payload, { value: valueWei });
          showMsg('route-msg', 'Tx: ' + tx.hash, 'info');
          await tx.wait();
          showMsg('route-msg', 'Trade routed.', 'ok');
          loadStats();
          loadVenues();
        } catch (e) {
          showMsg('route-msg', e.message || 'Route failed.', 'err');
        }
      });

      document.getElementById('btn-estimate-fee').addEventListener('click', async function() {
        const out = document.getElementById('estimate-out');
        const valueInput = document.getElementById('route-value').value.trim();
        if (!contract || !valueInput) { out.textContent = 'Attach contract and enter value.'; return; }
        try {
          const valueWei = valueInput.includes('.') || /^\d+$/.test(valueInput) ? ethers.parseEther(valueInput) : BigInt(valueInput);
          const fee = await contract.computeFeeForAmount(valueWei.toString());
          out.textContent = 'Fee: ' + ethers.formatEther(fee) + ' ETH\nNet to venue: ' + ethers.formatEther(valueWei - fee) + ' ETH';
        } catch (e) {
          out.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-load-fees').addEventListener('click', async function() {
        const detail = document.getElementById('fees-detail');
        if (!contract) { detail.textContent = 'Attach contract first.'; return; }
        try {
          const [treasuryFee, collectorFee] = await Promise.all([contract.getFeeTreasuryAccum(), contract.getFeeCollectorAccum()]);
          detail.textContent = 'Treasury: ' + ethers.formatEther(treasuryFee) + ' ETH\nFee collector: ' + ethers.formatEther(collectorFee) + ' ETH';
        } catch (e) {
          detail.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-sweep-treasury').addEventListener('click', async function() {
        const msgEl = document.getElementById('sweep-msg');
        msgEl.style.display = 'none';
        if (!contract || !signer) { msgEl.textContent = 'Connect wallet and attach contract.'; msgEl.className = 'msg err'; msgEl.style.display = 'block'; return; }
        try {
          const tx = await contract.sweepTreasuryFees();
          msgEl.textContent = 'Tx: ' + tx.hash; msgEl.className = 'msg info'; msgEl.style.display = 'block';
          await tx.wait();
          msgEl.textContent = 'Treasury fees swept.'; msgEl.className = 'msg ok';
          document.getElementById('btn-load-fees').click();
        } catch (e) {
          msgEl.textContent = e.message || 'Sweep failed (must be treasury).'; msgEl.className = 'msg err'; msgEl.style.display = 'block';
        }
      });

      document.getElementById('btn-sweep-collector').addEventListener('click', async function() {
        const msgEl = document.getElementById('sweep-msg');
        msgEl.style.display = 'none';
        if (!contract || !signer) { msgEl.textContent = 'Connect wallet and attach contract.'; msgEl.className = 'msg err'; msgEl.style.display = 'block'; return; }
        try {
          const tx = await contract.sweepCollectorFees();
          msgEl.textContent = 'Tx: ' + tx.hash; msgEl.className = 'msg info'; msgEl.style.display = 'block';
          await tx.wait();
          msgEl.textContent = 'Fee collector fees swept.'; msgEl.className = 'msg ok';
          document.getElementById('btn-load-fees').click();
        } catch (e) {
          msgEl.textContent = e.message || 'Sweep failed (must be fee collector).'; msgEl.className = 'msg err'; msgEl.style.display = 'block';
        }
      });

      document.getElementById('btn-load-config').addEventListener('click', async function() {
        const detail = document.getElementById('config-detail');
        if (!contract) { detail.textContent = 'Attach contract first.'; return; }
        try {
          const cfg = await contract.getConfig();
          detail.textContent = 'Treasury: ' + cfg[0] + '\nFee collector: ' + cfg[1] + '\nKeeper: ' + cfg[2] + '\nFee bps: ' + cfg[3] + '\nDeployed block: ' + cfg[4] + '\nPaused: ' + cfg[5];
        } catch (e) {
          detail.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-batch-register').addEventListener('click', async function() {
        const targetsRaw = document.getElementById('batch-targets').value.trim();
        const labelsRaw = document.getElementById('batch-labels').value.trim();
        const msgEl = document.getElementById('batch-register-msg');
        msgEl.style.display = 'none';
        if (!contract || !signer) { msgEl.textContent = 'Connect wallet and attach contract.'; msgEl.className = 'msg err'; msgEl.style.display = 'block'; return; }
        const targets = targetsRaw.split(/[\n,]+/).map(function(s) { return s.trim(); }).filter(Boolean);
        const labelsSplit = labelsRaw.split(/[\n,]+/).map(function(s) { return s.trim(); });
        const zeroHash = '0x' + '0'.repeat(64);
        const labels = targets.length > labelsSplit.length ? targets.map(function(_, i) { return labelsSplit[i] && labelsSplit[i].startsWith('0x') && labelsSplit[i].length === 66 ? labelsSplit[i] : zeroHash; }) : (labelsSplit.length ? labelsSplit.slice(0, targets.length).map(function(l) { return l && l.startsWith('0x') && l.length === 66 ? l : zeroHash; }) : targets.map(function() { return zeroHash; }));
        if (targets.length === 0) { msgEl.textContent = 'Enter at least one target address.'; msgEl.className = 'msg err'; msgEl.style.display = 'block'; return; }
        if (targets.length > 16) { msgEl.textContent = 'Max 16 per batch.'; msgEl.className = 'msg err'; msgEl.style.display = 'block'; return; }
        try {
          const tx = await contract.registerVenuesBatch(targets, labels);
          msgEl.textContent = 'Tx: ' + tx.hash; msgEl.className = 'msg info'; msgEl.style.display = 'block';
          await tx.wait();
          msgEl.textContent = 'Batch registered.'; msgEl.className = 'msg ok';
          loadVenues();
          loadStats();
        } catch (e) {
          msgEl.textContent = e.message || 'Batch register failed.'; msgEl.className = 'msg err'; msgEl.style.display = 'block';
        }
      });

      document.getElementById('btn-load-constants').addEventListener('click', async function() {
        const out = document.getElementById('constants-out');
        out.textContent = '';
        if (!contract) { out.textContent = 'Attach contract first.'; return; }
        try {
          const c = await contract.getConstants();
          out.textContent = 'BPS base: ' + c[0] + '\nMax fee bps: ' + c[1] + '\nMax venues: ' + c[2] + '\nMax batch quote: ' + c[3];
        } catch (e) {
          out.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      document.getElementById('btn-aggregate-stats').addEventListener('click', async function() {
        const out = document.getElementById('aggregate-stats-out');
        out.textContent = '';
        if (!contract) { out.textContent = 'Attach contract first.'; return; }
        try {
          const [vol, trades] = await Promise.all([contract.totalVolumeAcrossVenues(), contract.totalTradesAcrossVenues()]);
          out.textContent = 'Total volume (all venues): ' + ethers.formatEther(vol) + ' ETH\nTotal trades: ' + trades;
        } catch (e) {
          out.textContent = 'Error: ' + (e.message || 'unknown');
        }
      });

      btnConnect.addEventListener('click', connectWallet);
      btnAttach.addEventListener('click', function() { attachContract(contractInput.value.trim()); });
      contractInput.addEventListener('keydown', function(e) { if (e.key === 'Enter') attachContract(contractInput.value.trim()); });

      document.querySelectorAll('.tab').forEach(function(t) {
        t.addEventListener('click', function() {
          document.querySelectorAll('.tab').forEach(function(x) { x.classList.remove('active'); });
          document.querySelectorAll('.panel').forEach(function(x) { x.classList.remove('visible'); });
          t.classList.add('active');
          const id = 'panel-' + t.getAttribute('data-tab');
          const panel = document.getElementById(id);
          if (panel) panel.classList.add('visible');
          if (t.getAttribute('data-tab') === 'venues') loadVenues();
          if (t.getAttribute('data-tab') === 'fees') document.getElementById('btn-load-fees').click();
        });
      });
    })();
  </script>
</body>
</html>

